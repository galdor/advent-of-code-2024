(defpackage :aoc2024-09
  (:use :cl :aoc2024-utils)
  (:export
   #:*data*
   #:solve-1
   #:solve-2))

(in-package :aoc2024-09)

(defvar *data* (string-trim (string #\Newline) (input-file-data 9)))

(defun parse-disk-map (string)
  (let* ((digits (map 'vector (lambda (c)
                                (- (char-code c) (char-code #\0)))
                      string))
         (disk-size (reduce #'+ digits :initial-value 0))
         (disk (make-array disk-size :element-type '(or null integer)
                                     :initial-element nil)))
    (do ((i 0 (+ i 2))
         (j 0)
         (block-id 0 (1+ block-id)))
        ((>= i (length digits))
         disk)
      (dotimes (n (aref digits i))
        (setf (aref disk j) block-id)
        (incf j))
      (when (< (1+ i) (length digits))
        (incf j (aref digits (1+ i)))))))

(defun solve-1 ()
  (filesystem-checksum (compact-blocks (parse-disk-map *data*))))

(defun solve-2 ()
  (filesystem-checksum (compact-files (parse-disk-map *data*))))

(defun compact-blocks (disk)
  (do ((i 0 (1+ i))
       (j (1- (length disk))))
      ((>= i j)
       disk)
    (when (null (aref disk i))
      (rotatef (aref disk i) (aref disk j))
      (setf j (position-if-not #'null disk :from-end t :end j)))))

(defun compact-files (disk)
  (do ((file-id (find-if-not #'null disk :from-end t) (1- file-id))
       (j (length disk)))
      ((< file-id 0)
       disk)
    (let* ((last-block (position file-id disk :end j :from-end t))
           (first-block
             (1+ (or (position-if-not (lambda (block-id)
                                        (eql block-id file-id))
                                      disk :end last-block :from-end t)
                     -1)))
           (file-size (1+ (- last-block first-block))))
      (setf j first-block)
      (do ((i 0))
          ((>= i first-block)
           nil)
        (setf i (position nil disk :start i))
        (when (< i first-block)
          (let* ((free-space-end (or (position-if-not #'null disk :start i)
                                     (length disk)))
                 (free-space-size (- free-space-end i)))
            (when (>= free-space-size file-size)
              (dotimes (n file-size)
                (rotatef (aref disk (+ first-block n)) (aref disk (+ i n))))
              (return))
            (setf i free-space-end)))))))

(defun filesystem-checksum (disk)
  (do ((i 0 (1+ i))
       (checksum 0))
      ((>= i (length disk))
       checksum)
    (let ((block-id (aref disk i)))
      (when block-id
        (incf checksum (* i block-id))))))
